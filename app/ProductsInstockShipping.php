<?php

namespace App;
use App\Scopes\TestScope;
use Illuminate\Database\Eloquent\Builder;


/**
 * 非框架数据表模型
 * Class ProductsInstockShipping
 * @package App
 */
class ProductsInstockShipping extends Model
{
    //自定义表名
    protected $table = 'products_instock_shipping';
    //自定义主键
    protected $primaryKey = 'products_instock_id';
    //时间戳
    public $timestamps = false;

    /*
     * 事件
     * Eloquent 模型会触发许多事件，让你在模型的生命周期的多个时间点进行监控：
     * creating, created, updating, updated, saving, saved, deleting, deleted, restoring, restored.
     * 事件让你每当有特定的模型类在数据库保存或更新时，执行代码。
     * 当一个新模型被初次保存将会触发 creating 以及 created 事件。
     * 如果一个模型已经存在于数据库且调用了 save 方法，将会触发 updating 和 updated 事件。
     * 在这两种情况下都会触发 saving 和 saved 事件。
     * 开始前，在你的 Eloquent 模型上定义一个 $events 属性，将 Eloquent 模型的生命周期的多个点映射到你的 服务提供者 。*/
    /**
     * 模型的事件映射。
     *
     * @var array
     */
    protected $events = [
//        'saved' => UserSaved::class,
//        'deleted' => UserDeleted::class,
    ];


    /**
     * 应被转换为日期的属性。
     *
     * @var array
     */
    protected $dates = [
        //'created_at',
        //'updated_at',
        'sales_add_time',
        'sales_update_time',
    ];

    /**
     * 时间格式
     * 默认情况下，时间戳将会以 'Y-m-d H:i:s' 格式化。
     * 如果你想要自定义自己的时间戳格式，可在模型中设置 $dateFormat 属性。
     * 该属性定义了时间属性应如何被保存到数据库，以及模型应被序列化成一个数组或 JSON 格式
     */
    //protected $dateFormat = 'U';


    /**
     * 属性类型转换
     * $casts 属性在模型中提供了将属性转换为常见的数据类型的方法。$casts 属性应是一个数组，且键是那些需要被转换的属性名称，值则是代表字段要转换的类型。支持的转换的类型有：
        integer
        real
        float
        double
        string
        boolean
        object
        array
        collection
        date
        datetime
        timestamp
     */

    protected $casts = [
        //把属性转化为boolean
        'is_billing' => 'boolean',
        /*
         * 数组 & JSON 转换
         * 若原本字段保存的是被序列化的 JSON，则 array 类型转换将会特别有用。
         * 例如，在你的数据库中有一个 JSON 或 TEXT 字段类型，其包含了 被序列化的 JSON，且对该属性添加了 array 类型转换。
         * 当你在 Eloquent 模型上访问该属性时，它将会被自动反序列化成一个 PHP 数组：
         *
         * 一旦类型转换被定义，则可以访问 options 属性，它将会自动把 JSON 反序列化成一个 PHP 数组。
         * 当你设置 options 属性的值时，指定的数组将会被自动序列化成 JSON 以便进行保存*/
        'options' => 'array',
    ];

    /**
     * 访问器被附加到模型数组的形式。
     *
     * 一旦属性被添加到 appends 清单，便会将模型中的数组和 JSON 这两种形式都包含进去。
     * 在 appends 数组中的属性也遵循模型中 visible 和 hidden 设置
     * @var array
     */
    protected $appends = ['is_admin'];

    /**
     * 隐藏来自 JSON 的属性
     * 有时候你可能会想要限制包含在模型数组或 JSON 表示中的属性，比如说密码。
     * 则可以通过在模型中增加 $hidden 属性定义来实现
     */
    protected $hidden = ['orders_id'];
    /*也可以使用 visible 属性来定义应该包含在你的模型数组和 JSON 表示中的属性白名单。
    白名单外的其他属性将隐藏，不会出现在转换后的数组或 JSON 中*/
    protected $visible = ['order_products_price'];

    /**
     * 如果自定义主键了 这个方法可以不必
     * 自定义键名
     * 隐式模型绑定除 id 以外的数据库字段
     * @return string
     */
    public function getRouteKeyName()
    {
        //return parent::getRouteKeyName(); // TODO: Change the autogenerated stub
        return 'products_instock_id';
    }

    /**
     * 获取模型的路由键值.
     *
     * @return mixed
     */
    public function getRouteKey()
    {
        return 'products_instock_id';
    }

    /**
     * 应用全局作用域
     */
    protected static function boot()
    {
        parent::boot(); // TODO: Change the autogenerated stub

        //全局作用域  ProductsInstockShipping::all() 会生成 select * from `products_instock_shipping` where `id` > 200
        static::addGlobalScope(new TestScope());

        /*匿名的全局作用域
        Eloquent 还允许我们使用闭包定义全局作用域，
        这在实现简单作用域的时候特别有用，这样的话，我们就没必要定义一个单独的类了
        User::withoutGlobalScope('age')->get();*/
        static::addGlobalScope('age', function(Builder $builder) {
            $builder->where('orders_id', '>', 99664);
        });
    }

    /**
     * 本地作用域
     * 本地作用域允许我们定义通用的约束集合以便在应用中复用。
     * 例如，你可能经常需要获取最受欢迎的用户，要定义这样的一个作用域，
     * 只需简单在对应 Eloquent 模型方法前加上一个 scope 前缀，作用域总是返回查询构建器
     */
    public function ScopeId($query)
    {
        /*利用查询范围
        一旦定义了范围，则可以在查询模型时调用范围方法。在进行方法调用时不需要加上 scope 前缀。你甚至可以链式调用不同的范围
        $users = App\User::popular()->active()->orderBy('created_at')->get();*/
        return $query->where('orders_id', 99700);
    }

    /**
     * 动态范围
     * 有时候，你可能希望定义一个可接受参数的范围。这时只需给你的范围加上额外的参数即可。
     * 范围参数应该被定义在 $query 参数之后
     */
    public function ScopeDynamic($query, $type)
    {
        //$users = App\User::ofType('admin')->get();
        return $query->where('orders_id', $type);
    }

    /**
     * 获取用户的名字。
     *orders_id
     * @param  string  $value
     * @return string
     */
    public function getOrdersIdAttribute($value)
    {
        /*
     * 定义一个访问器
     * 若要定义一个访问器，则须在你的模型上创建一个 getFooAttribute 方法。
     * 要访问的 Foo 字段需使用「驼峰式」来命名。
     * 在这个例子中，我们将为 first_name 属性定义一个访问器。
     * 当 Eloquent 尝试获取 first_name 的值时，将会自动调用此访问器*/

        /*
         * 字段的原始值被传递到访问器中，让你可以编辑修改并返回结果。如果要访问被修改的值，则可以像这样来访问 first_name 属性*/
        return bcrypt($value);
    }

    /**
     * 为用户获取管理者的标记。
     *
     * @return bool
     */
    public function getIsAdminAttribute()
    {
        /*
         * 添加参数到 JSON 中
         * 有时候，在转换模型到 数组 或 JSON 时，你希望添加一个在数据库中没有对应字段的属性。
         * 首先你需要为这个值定义一个 访问器 ：
         *
         * 访问器创建成功后，只需添加该属性到改模型的 appends 属性中。
         * 注意，属性名称通常遵循 「Snake Case」 的命名方式，即是访问器的名称是基于 「Camel Case」 的命名方式。*/
        return $this->attributes['admin'] == 'yes';
    }

    /**
     * 设定用户的名字。
     *
     * @param  string  $value
     * @return void
     */
    public function setOrdersIdAttribute($value)
    {
        /*
         * 定义一个修改器
         * 若要定义一个修改器，则须在模型上定义一个 setFooAttribute 方法。
         * 要访问的 Foo 字段需使用「驼峰式」来命名。
         * 让我们再来定义 first_name 属性的修改器。
         * 当我们尝试在模型上设置 first_name 的值时，将会自动调用此修改器*/
        $this->attributes['orders_id'] = $value - 66;
    }


}
